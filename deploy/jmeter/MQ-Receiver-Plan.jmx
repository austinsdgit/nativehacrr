<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.6.3">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="MQ-Sender-Receiver-Plan">
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
        <collectionProp name="Arguments.arguments">
          <elementProp name="duration" elementType="Argument">
            <stringProp name="Argument.name">duration</stringProp>
            <stringProp name="Argument.value">120</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="warmup_duration" elementType="Argument">
            <stringProp name="Argument.name">warmup_duration</stringProp>
            <stringProp name="Argument.value">10</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="sender_threads" elementType="Argument">
            <stringProp name="Argument.name">sender_threads</stringProp>
            <stringProp name="Argument.value">500</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="receiver_threads" elementType="Argument">
            <stringProp name="Argument.name">receiver_threads</stringProp>
            <stringProp name="Argument.value">500</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="rate" elementType="Argument">
            <stringProp name="Argument.name">rate</stringProp>
            <stringProp name="Argument.value">99999999999</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="sender_connections" elementType="Argument">
            <stringProp name="Argument.name">sender_connections</stringProp>
            <stringProp name="Argument.value">5000</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="receiver_connections" elementType="Argument">
            <stringProp name="Argument.name">receiver_connections</stringProp>
            <stringProp name="Argument.value">5000</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath">/mnt/ibmmq/com.ibm.mq.allclient.jar,/mnt/ibmmq/jms.jar,/mnt/ibmmq/org.json.jar,/mnt/ibmmq/javax.jms-api-2.0.1.jar</stringProp>
    </TestPlan>
    <hashTree>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="MQ Connection Settings">
        <collectionProp name="Arguments.arguments">
          <elementProp name="qm_name" elementType="Argument">
            <stringProp name="Argument.name">qm_name</stringProp>
            <stringProp name="Argument.value">mq01ha</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Queue manager Name</stringProp>
          </elementProp>
          <elementProp name="qm_channel" elementType="Argument">
            <stringProp name="Argument.name">qm_channel</stringProp>
            <stringProp name="Argument.value">MQ.QS.SVRCONN</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Server channel to connect to </stringProp>
          </elementProp>
          <elementProp name="qm_conn_mode" elementType="Argument">
            <stringProp name="Argument.name">qm_conn_mode</stringProp>
            <stringProp name="Argument.value">client</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Connection Mode (client | bindings)</stringProp>
          </elementProp>
          <elementProp name="qm_host" elementType="Argument">
            <stringProp name="Argument.name">qm_host</stringProp>
            <stringProp name="Argument.value">occmq-mq01ha-ibm-mq.occmq.svc.cluster.local</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Queue manager host (only required for client mode)</stringProp>
          </elementProp>
          <elementProp name="qm_port" elementType="Argument">
            <stringProp name="Argument.name">qm_port</stringProp>
            <stringProp name="Argument.value">1414</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Queue manager listener port (only required for client mode)</stringProp>
          </elementProp>
          <elementProp name="qm_userid" elementType="Argument">
            <stringProp name="Argument.name">qm_userid</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Userid (will attempt to connect without credentials if not specified)</stringProp>
          </elementProp>
          <elementProp name="qm_pwd" elementType="Argument">
            <stringProp name="Argument.name">qm_pwd</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Password  (used if userid is set)</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="Message, Destination and QoS Settings">
        <collectionProp name="Arguments.arguments">
          <elementProp name="q_name" elementType="Argument">
            <stringProp name="Argument.name">q_name</stringProp>
            <stringProp name="Argument.value">DEV.QUEUE.1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Queue name (used as-is, if q_range is set to 1)</stringProp>
          </elementProp>
          <elementProp name="q_range" elementType="Argument">
            <stringProp name="Argument.name">q_range</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Queue range (if &gt;2 then queues ${q_name}1 to ${qname}${q_range} are used round-robin by threads)</stringProp>
          </elementProp>
          <elementProp name="persistent" elementType="Argument">
            <stringProp name="Argument.name">persistent</stringProp>
            <stringProp name="Argument.value">true</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Set to true for persistent messages</stringProp>
          </elementProp>
          <elementProp name="transacted" elementType="Argument">
            <stringProp name="Argument.name">transacted</stringProp>
            <stringProp name="Argument.value">true</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Set to true for transacted sends/receives. This should be set to the same value as &apos;persistent&apos; above.</stringProp>
          </elementProp>
          <elementProp name="msg_len" elementType="Argument">
            <stringProp name="Argument.name">msg_len</stringProp>
            <stringProp name="Argument.value">2048</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Length of message to be generated (only used if msg_file is not set below)</stringProp>
          </elementProp>
          <elementProp name="msg_file" elementType="Argument">
            <stringProp name="Argument.name">msg_file</stringProp>
            <stringProp name="Argument.value">/mnt/sample_msg.txt</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">File containing data to populate messages with (e.g. /tmp/testMsg.dat  ). Paths relative to JMeter bin directory can be used. For windows use / or \\ (i.e. c:/testfile.txt or c:\\testfile.txt)</stringProp>
          </elementProp>
          <elementProp name="msg_type" elementType="Argument">
            <stringProp name="Argument.name">msg_type</stringProp>
            <stringProp name="Argument.value">text</stringProp>
            <stringProp name="Argument.desc">Send message as String object (text) or stream of uninterpreted bytes (binary)  (text|binary)</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="receive_timeout" elementType="Argument">
            <stringProp name="Argument.name">receive_timeout</stringProp>
            <stringProp name="Argument.value">5000</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Timeout for consumer.receive call (milliseconds).</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <SetupThreadGroup guiclass="SetupThreadGroupGui" testclass="SetupThreadGroup" testname="setUp Thread Group (Receiver Connections)" enabled="true">
        <stringProp name="ThreadGroup.num_threads">${receiver_connections}</stringProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </SetupThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Create Receiver Connections to Queue Manager" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants

def invalidConnMode=false

 // Create a connection factory
def ff=JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def cf=ff.createConnectionFactory()

// Set the properties
cf.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER,&quot;${qm_name}&quot;)
cf.setStringProperty(WMQConstants.WMQ_CHANNEL,&quot;${qm_channel}&quot;)

if(&quot;${qm_conn_mode}&quot;.equals(&quot;bindings&quot;)) {
	cf.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE,WMQConstants.WMQ_CM_BINDINGS)
} else if (&quot;${qm_conn_mode}&quot;.equals(&quot;client&quot;)) {
	cf.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE,WMQConstants.WMQ_CM_CLIENT)
	cf.setStringProperty(WMQConstants.WMQ_HOST_NAME,&quot;${qm_host}&quot;)
	cf.setIntProperty(WMQConstants.WMQ_PORT,&quot;${qm_port}&quot; as Integer)
} else {
	log.error(&quot;####### ERROR: Invalid connection mode specified : &quot; + &quot;${qm_conn_mode}&quot; + &quot; ########&quot;)
	SampleResult.setSuccessful(false);
	invalidConnMode=true
}

if(!invalidConnMode){
	def connection
	
	if(&quot;${qm_userid}&quot;.equals(&quot;&quot;)) {
		connection=cf.createConnection()
	} else {
		connection=cf.createConnection(&quot;${qm_userid}&quot;,&quot;${qm_pwd}&quot;)
	}
	connection.start()
	log.info(&quot;####### Receiver connection #&quot; + ctx.getThreadNum() +  &quot; to queue manager &quot; + &quot;${qm_name}&quot;+ &quot; established.&quot;)

	//Store Connection
	System.getProperties().put(&quot;ReceiverConnection&quot;+ctx.getThreadNum(),connection)
}</stringProp>
        </JSR223Sampler>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Receivers" enabled="true">
        <stringProp name="ThreadGroup.num_threads">${receiver_threads}</stringProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <stringProp name="ThreadGroup.duration">${duration}</stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <intProp name="LoopController.loops">-1</intProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <OnceOnlyController guiclass="OnceOnlyControllerGui" testclass="OnceOnlyController" testname="Once Only Controller" enabled="true"/>
        <hashTree>
          <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Create JMS Session and JMS Consumer" enabled="true">
            <stringProp name="scriptLanguage">groovy</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="script">import javax.jms.Session

def connRange=Integer.parseInt(&quot;${receiver_connections}&quot;) 
connName=&quot;ReceiverConnection&quot;+ ((ctx.getThreadNum() % connRange))
log.debug(&quot;################Thread :&quot;+ctx.getThreadNum()+&quot; will use Connection: &quot;+connName)

def connection = System.getProperties().get(connName)

def qName
def qRange=Integer.parseInt(&quot;${q_range}&quot;) 

if(qRange &gt; 1){
	qName=&quot;${q_name}&quot; + ((ctx.getThreadNum() % qRange) +1)
	log.debug(&quot;############ qname:&quot; + qName)
} else {
	qName=&quot;${q_name}&quot;
}

def session

if(&quot;${transacted}&quot;.equals(&quot;true&quot;)){
	session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE)
} else {
	session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE)
}
def destination = session.createQueue(qName)
consumer = session.createConsumer(destination)	

//vars is thread scope
vars.putObject(&quot;ReceiverSession&quot;, session)	
vars.putObject(&quot;Consumer&quot;, consumer)</stringProp>
          </JSR223Sampler>
          <hashTree/>
          <RunTime guiclass="RunTimeGui" testclass="RunTime" testname="Receiver_warmup_timer" enabled="true">
            <stringProp name="RunTime.seconds">${warmup_duration}</stringProp>
          </RunTime>
          <hashTree>
            <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Receive Messages Warmup" enabled="true">
              <stringProp name="scriptLanguage">groovy</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="script">def consumer=vars.getObject(&quot;Consumer&quot;);
def session=vars.getObject(&quot;ReceiverSession&quot;)
 
def msg = consumer.receive(&quot;${receive_timeout}&quot; as Integer) 

if(msg!=null) {
	if(&quot;${transacted}&quot;.equals(&quot;true&quot;)) session.commit()
	
	log.debug(&quot;########### Message Received&quot;+msg)

	SampleResult.setResponseData(msg.toString())
	SampleResult.setDataType(org.apache.jmeter.samplers.SampleResult.TEXT)
} else {
	log.info(&quot;############ consumer.receive timed out (timeout value: &quot; + &quot;${receive_timeout}&quot; + &quot;)&quot;)
	//Mark timeout as &apos;error&apos; to enable filtering out in listeners (to just analyse successful receive rate etc)
	SampleResult.setSuccessful(false)
}
</stringProp>
            </JSR223Sampler>
            <hashTree/>
          </hashTree>
        </hashTree>
        <ConstantThroughputTimer guiclass="TestBeanGUI" testclass="ConstantThroughputTimer" testname="Set Receive Rate" enabled="true">
          <stringProp name="throughput">${__jexl2(${rate}*60)}</stringProp>
          <intProp name="calcMode">2</intProp>
        </ConstantThroughputTimer>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Receive Messages" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">def consumer=vars.getObject(&quot;Consumer&quot;);
def session=vars.getObject(&quot;ReceiverSession&quot;)
 
def msg = consumer.receive(&quot;${receive_timeout}&quot; as Integer) 

if(msg!=null) {
	if(&quot;${transacted}&quot;.equals(&quot;true&quot;)) session.commit()
	
	log.debug(&quot;########### Message Received&quot;+msg)

	SampleResult.setResponseData(msg.toString())
	SampleResult.setDataType(org.apache.jmeter.samplers.SampleResult.TEXT)
} else {
	log.info(&quot;############ consumer.receive timed out (timeout value: &quot; + &quot;${receive_timeout}&quot; + &quot;)&quot;)
	//Mark timeout as &apos;error&apos; to enable filtering out in listeners (to just analyse successful receive rate etc)
	SampleResult.setSuccessful(false)
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
      </hashTree>
      <PostThreadGroup guiclass="PostThreadGroupGui" testclass="PostThreadGroup" testname="tearDown Thread Group (Receiver Connections)" enabled="true">
        <stringProp name="ThreadGroup.num_threads">${receiver_connections}</stringProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </PostThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Close Receiver Connections" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">System.getProperties().get(&quot;ReceiverConnection&quot;+ctx.getThreadNum()).close()

log.info(&quot;###### Receiver Connection Closed&quot;)
</stringProp>
        </JSR223Sampler>
        <hashTree/>
      </hashTree>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree">
        <boolProp name="ResultCollector.error_logging">true</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename">/mnt/receiver-results.csv</stringProp>
        <boolProp name="ResultCollector.success_only_logging">true</boolProp>
      </ResultCollector>
      <hashTree/>
      <ResultCollector guiclass="StatGraphVisualizer" testclass="ResultCollector" testname="Aggregate Graph">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename">/mnt/receiver-results.jtl</stringProp>
      </ResultCollector>
      <hashTree/>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
