<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.6.3">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Test Plan">
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
    </TestPlan>
    <hashTree>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
        <collectionProp name="Arguments.arguments">
          <elementProp name="ARCA_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">ARCA_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">15</stringProp>
          </elementProp>
          <elementProp name="ARCA_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">ARCA_loopcounter</stringProp>
            <stringProp name="Argument.value">206345</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">206345</stringProp>
          </elementProp>
          <elementProp name="AMEX_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">AMEX_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">20</stringProp>
          </elementProp>
          <elementProp name="AMEX_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">AMEX_loopcounter</stringProp>
            <stringProp name="Argument.value">80793</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">284160</stringProp>
          </elementProp>
          <elementProp name="BATS_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">BATS_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="BATS_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">BATS_loopcounter</stringProp>
            <stringProp name="Argument.value">0</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="BOX_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">BOX_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="BOX_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">BOX_loopcounter</stringProp>
            <stringProp name="Argument.value">115307</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="C2_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">C2_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="C2_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">C2_loopcounter</stringProp>
            <stringProp name="Argument.value">43561</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="CFE_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">CFE_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="CFE_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">CFE_loopcounter</stringProp>
            <stringProp name="Argument.value">14967</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="EDGX_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">EDGX_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="EDGX_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">EDGX_loopcounter</stringProp>
            <stringProp name="Argument.value">102681</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="EMLD_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">EMLD_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="EMLD_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">EMLD_loopcounter</stringProp>
            <stringProp name="Argument.value">92534</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="GEM_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">GEM_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="GEM_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">GEM_loopcounter</stringProp>
            <stringProp name="Argument.value">42001</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="ISE_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">ISE_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="ISE_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">ISE_loopcounter</stringProp>
            <stringProp name="Argument.value">122243</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MCRY_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">MCRY_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MCRY_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">MCRY_loopcounter</stringProp>
            <stringProp name="Argument.value">51485</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MIAX_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">MIAX_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MIAX_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">MIAX_loopcounter</stringProp>
            <stringProp name="Argument.value">142727</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MPRL_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">MPRL_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MPRL_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">MPRL_loopcounter</stringProp>
            <stringProp name="Argument.value">51916</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="NOBO_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">NOBO_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="NOBO_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">NOBO_loopcounter</stringProp>
            <stringProp name="Argument.value">27469</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="PHLX_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">PHLX_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="PHLX_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">PHLX_loopcounter</stringProp>
            <stringProp name="Argument.value">111568</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SML_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">SML_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SML_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">SML_loopcounter</stringProp>
            <stringProp name="Argument.value">108</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="NSDQ_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">NSDQ_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="NSDQ_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">NSDQ_loopcounter</stringProp>
            <stringProp name="Argument.value">88864</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="CBOE_sleeptime" elementType="Argument">
            <stringProp name="Argument.name">CBOE_sleeptime</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="CBOE_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">CBOE_loopcounter</stringProp>
            <stringProp name="Argument.value">364145</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="filePath" elementType="Argument">
            <stringProp name="Argument.name">filePath</stringProp>
            <stringProp name="Argument.value">/home/adwiv02/Public/Data Files/Trades/20250116/Data/SplitFiles/</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="OOFfilePath" elementType="Argument">
            <stringProp name="Argument.name">OOFfilePath</stringProp>
            <stringProp name="Argument.value">/home/adwiv02/Public/Data Files/Trades/20250116/Data/SplitFiles/</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="OOF_loopcounter" elementType="Argument">
            <stringProp name="Argument.name">OOF_loopcounter</stringProp>
            <stringProp name="Argument.value">300000</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - ARCA - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - ARCA-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.ARCA&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMARCA.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

//String filepath = &quot;/home/spent01/Scripts/LoadTest/Day2/TradeFiles/0915/ARCA_Samp.txt&quot;;
String filepath = vars.get(&quot;filePath&quot;) + &quot;ARCAD0116_1.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;ARCA_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;ARCA_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/ARCA_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - ARCA - Batch 2" enabled="true">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">300</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - ARCA-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.ARCA&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMARCA.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;ARCAD0116_2.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);
	lc = Integer.parseInt(vars.get(&quot;ARCA_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;ARCA_sleeptime&quot;))
	String msg;
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/ARCA_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - ARCA - Batch 3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - ARCA-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.ARCA&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMARCA.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

//String filepath = &quot;H:\\LoadTesting\\1XVolume\\DataFiles\\ARCA\\1X\\Account\\ARCAD0116_3.txt&quot;;
String filepath = vars.get(&quot;filePath&quot;) + &quot;ARCAD0116_3.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);
	lc = Integer.parseInt(vars.get(&quot;ARCA_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;ARCA_sleeptime&quot;))
	
	String msg;
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/ARCA_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - ARCA - Batch 4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - ARCA-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.ARCA&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMARCA.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;ARCAD0116_4.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);
	lc = Integer.parseInt(vars.get(&quot;ARCA_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;ARCA_sleeptime&quot;))
	String msg;
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
// 	log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/ARCA_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - ARCA - Batch1-CA" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - ARCA-1-CA" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.ARCA&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMARCA.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = &quot;/home/spent01/Scripts/LoadTest/Day2/TradeFiles/0915/CA_Deals_1.txt&quot;;
//String filepath = vars.get(&quot;filePath&quot;) + &quot;ARCAD0116_1.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;ARCA_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;ARCA_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;65412;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/ARCA_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - ARCA - Batch2-CA" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - ARCA-2-CA" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.ARCA&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMARCA.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = &quot;/home/spent01/Scripts/LoadTest/Day2/TradeFiles/0915/CA_Deals_2.txt&quot;;
//String filepath = vars.get(&quot;filePath&quot;) + &quot;ARCAD0116_1.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;ARCA_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;ARCA_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;65412;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/ARCA_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - ARCA - Batch3-CA" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - ARCA-3-CA" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.ARCA&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMARCA.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = &quot;/home/spent01/Scripts/LoadTest/Day2/TradeFiles/0915/CA_Deals_3.txt&quot;;
//String filepath = vars.get(&quot;filePath&quot;) + &quot;ARCAD0116_1.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;ARCA_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;ARCA_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;65412;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/ARCA_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - ARCA - Batch4-CA" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - ARCA-4-CA" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.ARCA&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMARCA.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = &quot;/home/spent01/Scripts/LoadTest/Day2/TradeFiles/0915/CA_Deals_4.txt&quot;;
//String filepath = vars.get(&quot;filePath&quot;) + &quot;ARCAD0116_1.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;ARCA_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;ARCA_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;65412;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/ARCA_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - AMEX - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - AMEX-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.AMEX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMAMEX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;AMEXD0116_1.txt&quot;;

//String filepath = &quot;/home/spent01/Scripts/LoadTest/Day2/TradeFiles/0118/ForCA/IBM_R4.txt&quot;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;AMEX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;AMEX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/AMEX_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - AMEX - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - AMEX-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.AMEX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMAMEX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;AMEXD0116_2.txt&quot;;
//String filepath = &quot;/home/spent01/Scripts/LoadTest/Day2/TradeFiles/0118/ForCA/BBY_R4.txt&quot;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;AMEX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;AMEX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/AMEX_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - AMEX - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - AMEX-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.AMEX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMAMEX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;AMEXD0116_3.txt&quot;;
//String filepath = &quot;/home/spent01/Scripts/LoadTest/Day2/TradeFiles/0118/ForCA/ADSK_R4.txt&quot;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;AMEX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;AMEX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/AMEX_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - AMEX - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - AMEX-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.AMEX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMAMEX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;AMEXD0116_4.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;AMEX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;AMEX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/AMEX_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - AMEX - Batch5" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - AMEX-5" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.AMEX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMAMEX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;AMEXD0116_5.txt&quot;;

//String filepath = &quot;/home/spent01/Scripts/LoadTest/Day2/TradeFiles/0118/ForCA/IBM_R4.txt&quot;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;AMEX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;AMEX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/AMEX_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - AMEX - Batch6" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - AMEX-6" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.AMEX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMAMEX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;AMEXD0628_6.txt&quot;;
//String filepath = &quot;/home/spent01/Scripts/LoadTest/Day2/TradeFiles/0118/ForCA/BBY_R4.txt&quot;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;AMEX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;AMEX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/AMEX_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - AMEX - Batch7" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - AMEX-7" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.AMEX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMAMEX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;AMEXD0628_7.txt&quot;;
//String filepath = &quot;/home/spent01/Scripts/LoadTest/Day2/TradeFiles/0118/ForCA/ADSK_R4.txt&quot;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;AMEX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;AMEX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/AMEX_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - AMEX - Batch8" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - AMEX-8" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.AMEX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMAMEX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;AMEXD0628_8.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;AMEX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;AMEX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/AMEX_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - BATS - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - BATS-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.BATS&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMBATS.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;BATSD0116_1.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;BATS_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;BATS_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/BATS_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - BATS - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - BATS-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.BATS&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMBATS.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;BATSD0116_2.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;BATS_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;BATS_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/BATS_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - BATS - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - BATS-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.BATS&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMBATS.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;BATSD0116_3.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;BATS_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;BATS_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/BATS_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - BATS - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - BATS-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.BATS&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMBATS.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;BATSD0116_4.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;BATS_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;BATS_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/BATS_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - BOX - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - BOX-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.BOX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMBOX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;BOXD0116_1.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;BOX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;BOX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/BOX_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - BOX - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - BOX-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.BOX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMBOX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
   String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;BOXD0116_2.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;BOX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;BOX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/BOX_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - BOX - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - BOX-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.BOX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMBOX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;BOXD0116_3.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;BOX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;BOX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/BOX_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - BOX - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - BOX-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.BOX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMBOX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;BOXD0116_4.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;BOX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;BOX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/BOX_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - C2 - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - C2-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.C2&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMC2.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;C2D0116_1.txt&quot;;
//String filepath = &quot;H:\\Sudheer\\2023\\Scripts\\RTC\\TRADEFILES\\15SepTrades\\C2.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;C2_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;C2_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/C2_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - C2 - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - C2-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.C2&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMC2.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;C2D0116_2.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;C2_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;C2_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/C2_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - C2 - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - C2-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.C2&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMC2.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;C2D0116_3.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;C2_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;C2_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/C2_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - C2 - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - C2-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.C2&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMC2.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;C2D0116_4.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;C2_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;C2_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/C2_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - CFE - OOF Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - CFE-OOF-Batch1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.CFE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMCFE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;OOFfilePath&quot;) + &quot;OOF_300K.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;OOF_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;CFE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/CFE_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - CFE - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - CFE-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.CFE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMCFE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;CFED0116_1.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;CFE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;CFE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/CFE_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - CFE - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - CFE-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.CFE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMCFE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;CFED0116_2.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;CFE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;CFE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/CFE_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - CFE - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - CFE-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.CFE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMCFE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;CFED0116_3.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;CFE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;CFE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/CFE_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - CFE - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - CFE-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.CFE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMCFE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;CFED0116_4.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;CFE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;CFE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/CFE_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - EDGX - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - EDGX-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.EDGX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMEDGX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;EDGXD0116_1.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;EDGX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;EDGX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/EDGX_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - EDGX - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - EDGX-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.EDGX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMEDGX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;EDGXD0116_2.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;EDGX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;EDGX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
 </stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/EDGX_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - EDGX - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - EDGX-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.EDGX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMEDGX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;EDGXD0116_3.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;EDGX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;EDGX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/EDGX_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - EDGX - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - EDGX-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.EDGX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMEDGX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;EDGXD0116_4.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;EDGX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;EDGX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/EDGX_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - EMLD - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - EMLD-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.EMLD&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMEMLD.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;EMLDD0116_1.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;EMLD_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;EMLD_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/EMLD_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - EMLD - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - EMLD-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.EMLD&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMEMLD.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;EMLDD0116_2.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;EMLD_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;EMLD_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/EMLD_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - EMLD - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - EMLD-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.EMLD&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMEMLD.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;EMLDD0116_3.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;EMLD_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;EMLD_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/EMLD_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - EMLD - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - EMLD-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.EMLD&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMEMLD.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;EMLDD0116_4.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;EMLD_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;EMLD_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/EMLD_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - GEM - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - GEM-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.GEM&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMGEM.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;GEMD0116_1.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;GEM_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;GEM_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/GEM_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - GEM - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - GEM-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.GEM&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMGEM.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;GEMD0116_2.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;GEM_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;GEM_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/GEM_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - GEM - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - GEM-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.GEM&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMGEM.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;GEMD0116_3.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;GEM_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;GEM_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/GEM_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - GEM - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - GEM-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.GEM&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMGEM.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
   String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;GEMD0116_4.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;GEM_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;GEM_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/GEM_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - ISE - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - ISE-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.ISE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMISE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;ISED0116_1.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;ISE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;ISE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/ISE_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - ISE - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - ISE-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.ISE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMISE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;ISED0116_2.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;ISE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;ISE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/ISE_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - ISE - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - ISE-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.ISE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMISE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
   String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;ISED0116_3.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;ISE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;ISE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/ISE_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - ISE - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - ISE-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.ISE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMISE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;ISED0116_4.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;ISE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;ISE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/ISE_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - MCRY - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler -MCRY-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.MCRY&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMMCRY.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;MCRYD0116_1.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;MCRY_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;MCRY_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/MCRY_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - MCRY - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - MCRY-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.MCRY&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMMCRY.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;MCRYD0116_2.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;MCRY_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;MCRY_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/MCRY_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - MCRY - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - MCRY-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.MCRY&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMMCRY.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;MCRYD0116_3.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;MCRY_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;MCRY_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/MCRY_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - MCRY - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - MCRY-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.MCRY&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMMCRY.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;MCRYD0116_4.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;MCRY_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;MCRY_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/MCRY_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - MIAX - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - MIAX-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.MIAX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMMIAX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;MIAXD0116_1.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;MIAX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;MIAX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/MIAX_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - MIAX - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - MIAX-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.MIAX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMMIAX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;MIAXD0116_2.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;MIAX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;MIAX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/MIAX_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - MIAX - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - MIAX-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.MIAX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMMIAX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
   String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;MIAXD0116_3.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;MIAX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;MIAX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/MIAX_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - MIAX - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - MIAX-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.MIAX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMMIAX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;MIAXD0116_4.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;MIAX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;MIAX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/MIAX_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - MPRL - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - MPRL-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.MPRL&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMMPRL.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;MPRLD0116_1.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;MPRL_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;MPRL_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/MPRL_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - MPRL - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler -MPRL-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.MPRL&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMMPRL.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;MPRLD0116_2.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;MPRL_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;MPRL_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/MPRL_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - MPRL - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - MPRL-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.MPRL&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMMPRL.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
   String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;MPRLD0116_3.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;MPRL_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;MPRL_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/MPRL_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - MPRL - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - MPRL-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.MPRL&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMMPRL.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
   String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;MPRLD0116_4.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;MPRL_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;MPRL_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/MPRL_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - NOBO - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - NOBO-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.NOBO&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMNOBO.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;NOBOD0116_1.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;NOBO_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;NOBO_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/NOBO_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - NOBO - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - NOBO-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.NOBO&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMNOBO.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;NOBOD0116_2.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;NOBO_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;NOBO_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/NOBO_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - NOBO - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - NOBO-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.NOBO&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMNOBO.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;NOBOD0116_3.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;NOBO_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;NOBO_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/NOBO_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - NOBO - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - NOBO-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.NOBO&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMNOBO.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;NOBOD0116_4.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;NOBO_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;NOBO_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/NOBO_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - PHLX - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - PHLX-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.PHLX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMPHLX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;PHLXD0116_1.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;PHLX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;PHLX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/PHLX_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - PHLX - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - PHLX-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.PHLX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMPHLX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;PHLXD0116_2.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;PHLX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;PHLX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/PHLX_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - PHLX - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - PHLX-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.PHLX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMPHLX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;PHLXD0116_3.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;PHLX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;PHLX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/PHLX_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - PHLX - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - PHLX-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.PHLX&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMPHLX.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;PHLXD0116_4.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;PHLX_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;PHLX_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/PHLX_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - SML - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - Final with reading from file" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;tutla24l.theocc.com&quot;
def hostPort=1429
def channelName=&quot;TESTBENCH.TO.TRENTRD&quot;
def queueManagerName=&quot;TRENTRD&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMSML.REGULAR.46&quot;
def queueName=&quot;TRADEVAL.MATCHED.E2.FROMSML.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;
log.info(&quot;Queue is&quot; + queueName)
java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    //String keystorePath = &quot;rtc_mq_client.jks&quot; 
    String keystorePath = vars.get(&quot;jksFile&quot;)

    log.info(&quot;Cert file is&quot; + keystorePath)
    String keystorePassword = &quot;T1@W3lc0meRpt&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = &quot;H:\\LoadTesting\\1XVolume\\DataFiles\\SML\\SMLD0118.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;SML_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;SML_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">H:\LoadTesting\1XVolume\Results\SML\SML_Batch1</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - SML - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - Final with reading from file" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;tutla24l.theocc.com&quot;
def hostPort=1429
def channelName=&quot;TESTBENCH.TO.TRENTRD&quot;
def queueManagerName=&quot;TRENTRD&quot;
def queueName=&quot;TRADEVAL.MATCHED.E2.FROMSML.REGULAR.46&quot;
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
//String keystorePath = &quot;rtc_mq_client.jks&quot; 
    String keystorePath = vars.get(&quot;jksFile&quot;)
    String keystorePassword = &quot;T1@W3lc0meRpt&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = &quot;H:\\LoadTesting\\1XVolume\\DataFiles\\SML\\SMLD0116_2.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;SML_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;SML_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">H:\LoadTesting\1XVolume\Results\SML\SML_Batch2</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - SML - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - Final with reading from file" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;tutla24l.theocc.com&quot;
def hostPort=1429
def channelName=&quot;TESTBENCH.TO.TRENTRD&quot;
def queueManagerName=&quot;TRENTRD&quot;
def queueName=&quot;TRADEVAL.MATCHED.E2.FROMSML.REGULAR.46&quot;
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
//String keystorePath = &quot;rtc_mq_client.jks&quot; 
    String keystorePath = vars.get(&quot;jksFile&quot;)
    String keystorePassword = &quot;T1@W3lc0meRpt&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = &quot;H:\\LoadTesting\\1XVolume\\DataFiles\\SML\\SMLD0116_3.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;SML_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;SML_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">H:\LoadTesting\1XVolume\Results\SML\SML_Batch3</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - SML - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - Final with reading from file" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;tutla24l.theocc.com&quot;
def hostPort=1429
def channelName=&quot;TESTBENCH.TO.TRENTRD&quot;
def queueManagerName=&quot;TRENTRD&quot;
def queueName=&quot;TRADEVAL.MATCHED.E2.FROMSML.REGULAR.46&quot;
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
//String keystorePath = &quot;rtc_mq_client.jks&quot; 
    String keystorePath = vars.get(&quot;jksFile&quot;)
    String keystorePassword = &quot;T1@W3lc0meRpt&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = &quot;H:\\LoadTesting\\1XVolume\\DataFiles\\SML\\SMLD0116_4.txt&quot;;
//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;SML_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;SML_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">H:\LoadTesting\1XVolume\Results\SML\SML_Batch4</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - CBOE - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler -CBOE-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session
import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.CBOE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMCBOE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;CBOED0116_1.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;CBOE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;CBOE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/CBOE_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - CBOE - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - CBOE-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.CBOE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMCBOE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;CBOED0116_2.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;CBOE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;CBOE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/CBOE_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - CBOE - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - CBOE-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.CBOE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMCBOE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;CBOED0116_3.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;CBOE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;CBOE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/CBOE_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - CBOE - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - CBOE-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.CBOE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMCBOE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;CBOED0116_4.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;CBOE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;CBOE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/CBOE_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - CBOE - Batch5" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - CBOE-5" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.CBOE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMCBOE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;CBOED0116_5.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;CBOE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;CBOE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/CBOE_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - CBOE - Batch6" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - CBOE-6" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.CBOE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMCBOE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;CBOED0628_6.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;CBOE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;CBOE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/CBOE_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - CBOE - Batch7" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - CBOE-7" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.CBOE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMCBOE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;CBOED0628_7.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;CBOE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;CBOE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/CBOE_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - CBOE - Batch8" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - CBOE-8" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.CBOE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMCBOE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;CBOED0628_8.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;CBOE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;CBOE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/CBOE_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - NSDQ - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <longProp name="ThreadGroup.duration">1800</longProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - NSDQ-1" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.NSDQ&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMNSDQ.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;NSDQD0116_1.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;NSDQ_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;NSDQ_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/NSDQ_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - NSDQ - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - NSDQ-2" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.NSDQ&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMNSDQ.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;NSDQD0116_2.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;NSDQ_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;NSDQ_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/NSDQ_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - NSDQ - Batch3" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - NSDQ-3" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.NSDQ&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMNSDQ.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;NSDQD0116_3.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;NSDQ_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;NSDQ_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/NSDQ_Batch3.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - NSDQ - Batch4" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - NSDQ-4" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.NSDQ&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMNSDQ.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;NSDQD0116_4.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;NSDQ_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;NSDQ_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;lc;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/NSDQ_Batch4.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - CBOE - Batch1" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler -CBOE-1_RemPos" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session
import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.CBOE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMCBOE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;CBOED0118_03002_R38.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;CBOE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;CBOE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;60000;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/CBOE_Batch1.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group - CBOE - Batch2" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - CBOE-2_Rempos" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import com.ibm.msg.client.jms.JmsConnectionFactory
import com.ibm.msg.client.jms.JmsFactoryFactory
import com.ibm.msg.client.wmq.WMQConstants
import javax.jms.Session

import javax.jms.TextMessage
import javax.jms.MessageProducer
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.*
import java.security.KeyStore
import java.io.FileInputStream
import java.lang.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


def hostName=&quot;sittrd.2c.nc.theocc.com&quot;
def hostPort=1429
def channelName=&quot;RTC.TO.SITTRD&quot;
def queueManagerName=&quot;SITTRD&quot;
def queueName=&quot;TCH.20.CLRG.TRADES.CBOE&quot;
//def queueName=&quot;TRADEVAL.MATCHED.E2.FROMCBOE.REGULAR.&quot; + vars.get(&quot;env&quot;)
def cipherSuite = &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;
def sslPeerName = &quot;&quot;

java.lang.System.setProperty(&quot;com.ibm.mq.cfg.useIBMCipherMappings&quot;, &quot;false&quot;)
def factoryFactoryInstance = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER)
def connectionFactory = factoryFactoryInstance.createConnectionFactory()

try {
    connectionFactory.setStringProperty(WMQConstants.WMQ_HOST_NAME, hostName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_PORT, hostPort)
    connectionFactory.setStringProperty(WMQConstants.WMQ_CHANNEL, channelName)
    connectionFactory.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT)
    connectionFactory.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManagerName)
//Added for USER_AUTHENTICATION_MQCSP
    connectionFactory.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false)
    connectionFactory.setStringProperty(WMQConstants.USERID, &quot;srvc_rtc_mq&quot;)
    
    // Load the keystore
    String keystoreType = &quot;jks&quot; 
    String keystorePath = &quot;rtc_mq_client_07312024.jks&quot; 
    String keystorePassword = &quot;RATironCondor1@OCC&quot;
    
    KeyStore ks = KeyStore.getInstance(keystoreType)
    FileInputStream fis = new FileInputStream(keystorePath)
    ks.load(fis, keystorePassword.toCharArray())
    
    // Init the KeyManagerFactory with the keystore
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
    kmf.init(ks, keystorePassword.toCharArray())
    
    // Init the TrustManagerFactory with the keystore
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
    tmf.init(ks)
    
    // Init SSLContext with the key managers and trust managers
    SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;)
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new java.security.SecureRandom())
    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory()

    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SPEC, cipherSuite)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_CIPHER_SUITE, &quot;&quot;)
    connectionFactory.setObjectProperty(WMQConstants.WMQ_SSL_SOCKET_FACTORY, sslSocketFactory)
    connectionFactory.setStringProperty(WMQConstants.WMQ_SSL_PEER_NAME, sslPeerName)

    def jmsConnection = connectionFactory.createConnection()
    def jmsSession = jmsConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)
    def destinationQueue = jmsSession.createQueue(queueName)

    log.info(&quot;### MQ setup completed&quot;)

    def messageProducer = jmsSession.createProducer(destinationQueue)

String filepath = vars.get(&quot;filePath&quot;) + &quot;CBOED0118_04002_R38.txt&quot;;

//StringBuilder filecontent = new StringBuilder();
try {
	FileReader fr = new FileReader(filepath);
	BufferedReader br = new BufferedReader(fr);

	String msg;
	lc = Integer.parseInt(vars.get(&quot;CBOE_loopcounter&quot;))
	sleep_time = Integer.parseInt(vars.get(&quot;CBOE_sleeptime&quot;))
	//log.info(&quot;loopcounter is&quot; + lc)
	
	for(i=0;i&lt;60000;i++){
	msg = br.readLine()
		//StringBuilder filecontent = new StringBuilder();
	//filecontent.append(msg);
	//vars.put(&quot;filecontent&quot;,filecontent.toString());
	//log.info(&quot;in Beanshell:*******&quot; + filecontent);
	message = msg.toString()
   def textMessage = jmsSession.createTextMessage(message)
    messageProducer.send(textMessage)
    Thread.sleep(sleep_time)
 	//log.info(&quot;Message : &quot; + msg);
	}
	br.close();
}
catch (IOException e) {
	log.error(&quot;Error reading the file: &quot; + e.getMessage());
}

    
    
    log.info(&quot;### Message sent successfully&quot;)

} 
catch (Exception e) {
    log.error(&quot;Exception: &quot; + e.toString())
    e.printStackTrace()
}
finally {
    messageProducer?.close()
    jmsSession?.close()
    jmsConnection?.close()
}
</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">/home/spent01/Scripts/LoadTest/Day2/Results/5XR4/CBOE_Batch2.csv</stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
